# ═══════════════════════════════════════════════════════════════════
# SHORT SUMMARY
# ═══════════════════════════════════════════════════════════════════

DOCUMENT: Vessel Location Determination - Geographic Origin for Proximity Scoring
PURPOSE: Define how AI determines vessel's actual location before applying proximity scoring
SCOPE: Pre-processing step for P1 (Proximity) criterion
INTEGRATION: Critical input for proximity_scoring_matrix.txt - determines vessel_location

WHAT THIS DOCUMENT DEFINES:
This file establishes the authoritative methodology for determining a vessel's 
geographic location before calculating proximity scores. Since proximity scoring
requires knowing where the vessel is, this logic must execute FIRST to establish
the vessel_location input for the Proximity Scoring Matrix.

PRIORITY SYSTEM (4 levels):
1. Open Information (HIGHEST) - Vessel's declared open position
   - open_area, open_port, alternative_open_areas
2. Destination - Where vessel is heading (if valid geographic)
   - Must validate: real location vs non-geographic text
3. Current Area - Where vessel currently is (fallback)
   - From AIS or last known position
4. Unknown - Location cannot be determined (skip proximity scoring)

KEY FEATURES:
- Strict priority hierarchy (always check in order)
- Geographic validation (filters "to order", "TBN", crew info, etc.)
- Multiple open areas handling (select closest to loading port)
- Fuzzy matching for ports/regions (handles typos, variations)
- Edge case handling (outdated dates, contradictory data, ambiguous regions)
- Returns normalized geographic entity (port, region, country, sea)

CRITICAL DEPENDENCIES:
- proximity_scoring_matrix.txt: Uses output as vessel_location input
- Ports database: For geographic validation
- Regions/Seas lists: For fuzzy matching

VALIDATION LOGIC:
Valid Geographic:
- Port names: "Istanbul", "Constanta", "Odessa"
- Regions: "Black Sea", "Marmara Sea", "East Med"
- Countries: "Turkey", "Romania", "Ukraine"

Invalid Non-Geographic:
- Orders: "to order", "for orders", "awaiting orders"
- Nominations: "TBN", "TBA", "to be nominated"
- Crew info: "Syrian crew", "Greek crew onboard"
- Instructions: "INCO", "awaiting instructions", "owners option"

MULTIPLE OPEN AREAS SELECTION:
When vessel has multiple alternative open areas (e.g., ["Marmara Sea", "East Med", "Adriatic"]):
- Calculate proximity score from each area to cargo loading port
- Select area with HIGHEST proximity score
- Use selected area for all downstream scoring

EXAMPLE USAGE:
Input:
  open_area: null
  destination: "to order"
  current_area: "Marmara Sea"
Output:
  selected_location: "Marmara Sea"
  reasoning: "Destination invalid (non-geographic), using current_area (priority 3)"


# ═══════════════════════════════════════════════════════════════════
# HOW TO USE DOCUMENT
# ═══════════════════════════════════════════════════════════════════

## FOR DEVELOPERS (Laravel ↔ LangChain Integration)

### Data Flow:
1. **Laravel** retrieves vessel position data:
   - vessel_data table: open_date, open_port, open_area, destination, current_area
   - vessel_attributes table: alternative_open_areas (if exists)
   - Parse from email positions or AIS data

2. **Laravel** sends to **LangChain Python microservice**:
   ```json
   {
     "vessel_data": {
       "open_date": "2024-12-10",
       "open_port": "Istanbul",
       "open_area": "Marmara Sea",
       "alternative_open_areas": ["Marmara Sea", "East Med"],
       "destination": "Black Sea",
       "current_area": "Turkish Straits"
     },
     "cargo": {
       "loading_port": "Odessa, Ukraine",
       "loading_region": "Black Sea"
     }
   }
   ```

3. **LangChain/AI** determines location:
   - Apply 4-level priority system
   - Validate geographic vs non-geographic
   - Handle multiple open areas if present
   - Return normalized location

4. **LangChain/AI** returns:
   ```json
   {
     "vessel_location": {
       "selected": "Istanbul, Marmara Sea",
       "type": "port",
       "region": "Marmara Sea",
       "priority_level": 1,
       "source": "open_port"
     },
     "determination_process": {
       "step_1_open_info": {
         "available": true,
         "open_port": "Istanbul",
         "open_area": "Marmara Sea",
         "selected": true
       },
       "step_2_destination": {
         "checked": false,
         "reason": "Open info available, destination not needed"
       },
       "step_3_current_area": {
         "checked": false,
         "reason": "Open info available"
       },
       "reasoning": "Open port 'Istanbul' available (priority 1), most specific location"
     }
   }
   ```

5. **Pass to Proximity Scoring:**
   ```json
   {
     "vessel_location": "Istanbul, Marmara Sea",
     "cargo_loading_port": "Odessa, Ukraine",
     "vessel_dwt": 8500
   }
   → proximity_scoring_matrix.txt calculates P1 score
   ```

### Important Notes:
- Location determination MUST run BEFORE proximity scoring
- If location = null → skip proximity scoring (P1 = 0)
- Multiple open areas require proximity calculation for selection
- Geographic validation is critical (filters non-geographic text)
- Priority order is strict - never skip steps
- Output must be normalized geographic entity

### Database Field Names:
```
Verify actual field names in production:
- vessel_data.open_date
- vessel_data.open_port_id (FK to ports)
- vessel_data.open_area
- vessel_data.destination
- vessel_data.current_area
- vessel_attributes.alternative_open_areas (if exists)
```

---

## FOR AI/LangChain (Location Determination Implementation)

### Step-by-Step Algorithm:

**STEP 1: Check Open Information (Priority 1)**
```
Open information is HIGHEST priority - always check first.

Check open_port:
  IF open_port IS NOT NULL AND open_port != "":
    RETURN open_port as vessel_location
    REASONING: "Open port available (priority 1), most specific"
    
Check open_area:
  IF open_area IS NOT NULL AND open_area != "":
    RETURN open_area as vessel_location
    REASONING: "Open area available (priority 1)"
    
Check alternative_open_areas:
  IF alternative_open_areas is array with multiple values:
    FOR each area in alternative_open_areas:
      Calculate proximity_score(area, cargo_loading_port)
    SELECT area with HIGHEST proximity_score
    RETURN selected_area as vessel_location
    REASONING: "Multiple open areas, selected closest to loading port"
    
Check open_date validity:
  IF open_date exists:
    Calculate days_since_open = current_date - open_date
    IF days_since_open > 30:
      WARN: "Open date outdated (>30 days), consider current_area instead"
      
If ALL open information checks fail: PROCEED to Step 2
```

**STEP 2: Check Destination (Priority 2)**
```
Only check if Step 1 (open information) unavailable.

Get destination value:
  IF destination IS NULL OR destination = "":
    PROCEED to Step 3
    
Validate geographic:
  # Check for non-geographic keywords first
  non_geographic_keywords = [
    "to order", "for orders", "awaiting orders",
    "TBN", "TBA", "to be nominated", "to be advised",
    "crew", "onboard", "Syrian crew", "Greek crew",
    "INCO", "awaiting instructions", "owners option"
  ]
  
  IF destination.lower() contains ANY non_geographic_keywords:
    is_valid = FALSE
    REASON: "Non-geographic keyword detected"
    PROCEED to Step 3
    
  # Check against geographic database
  ELSE IF destination matches ports_database:
    is_valid = TRUE
    RETURN destination as vessel_location
    REASONING: "Valid port destination (priority 2)"
    
  ELSE IF destination matches regions_list:
    is_valid = TRUE
    RETURN destination as vessel_location
    REASONING: "Valid region destination (priority 2)"
    
  ELSE IF destination matches countries_list:
    is_valid = TRUE
    RETURN destination as vessel_location
    REASONING: "Valid country destination (priority 2)"
    
  ELSE:
    # Try fuzzy matching for typos
    fuzzy_match = fuzzy_search(destination, ports_database)
    IF fuzzy_match.score > 0.8:
      is_valid = TRUE
      RETURN fuzzy_match.location as vessel_location
      REASONING: "Fuzzy matched destination (priority 2)"
    ELSE:
      is_valid = FALSE
      PROCEED to Step 3
```

**STEP 3: Check Current Area (Priority 3)**
```
Fallback when both open information and valid destination unavailable.

Check current_area:
  IF current_area IS NOT NULL AND current_area != "":
    RETURN current_area as vessel_location
    REASONING: "Open info and valid destination unavailable, using current area (priority 3)"
    
  ELSE:
    PROCEED to Step 4
```

**STEP 4: Location Unknown (Priority 4)**
```
Last resort when all previous steps fail.

No location available:
  RETURN None as vessel_location
  REASONING: "No valid location data available"
  ACTION: "Skip proximity scoring (P1 = 0)"
  FLAG: "Manual review required"
```

**STEP 5: Handle Multiple Open Areas**
```
When alternative_open_areas array has multiple values:

FOR each area in alternative_open_areas:
  # Use proximity scoring matrix for each area
  temp_vessel_location = area
  temp_cargo_loading = cargo_loading_port
  temp_vessel_size = vessel_size_category
  
  # Calculate proximity score
  proximity_score = calculate_proximity(
    vessel_location=temp_vessel_location,
    cargo_loading=temp_cargo_loading,
    vessel_size=temp_vessel_size
  )
  
  # Store result
  scores[area] = proximity_score
  
# Select area with highest score
selected_area = max(scores, key=scores.get)
RETURN selected_area

Example:
  areas = ["Marmara Sea", "East Med", "Adriatic"]
  cargo_loading = "Odessa, Black Sea"
  
  scores = {
    "Marmara Sea": 19.04,
    "East Med": 10.44,
    "Adriatic": 5.96
  }
  
  selected = "Marmara Sea" (highest score)
```

**STEP 6: Validate and Normalize Output**
```
Ensure output is standardized geographic entity:

Types of valid outputs:
- Port: "Istanbul", "Constanta", "Odessa"
- Region: "Black Sea", "Marmara Sea", "East Med"
- Country: "Turkey", "Romania", "Greece"
- Sea: "Black Sea", "Mediterranean Sea"

Format:
  {
    "vessel_location": "normalized_name",
    "type": "port|region|country|sea",
    "priority_level": 1|2|3|4,
    "source": "open_port|open_area|destination|current_area|unknown",
    "reasoning": "human-readable explanation"
  }
```

**STEP 7: Return to Proximity Scoring**
```
If vessel_location is NOT None:
  PASS to proximity_scoring_matrix.txt:
    - vessel_location (from this determination)
    - cargo_loading_port (from cargo data)
    - vessel_size_category (from vessel_size_classification.txt)
    
  CALCULATE P1 score using proximity matrix
  
Else:
  P1_score = 0
  REASONING: "Vessel location unknown, cannot calculate proximity"
```

### Critical Reminders:
- ⚠️ ALWAYS run this BEFORE proximity scoring
- ⚠️ Priority order is STRICT - never skip steps
- ⚠️ Geographic validation is CRITICAL - filters non-geographic text
- ⚠️ Multiple open areas require proximity calculation for selection
- ⚠️ Return normalized geographic entity, not raw text
- ⚠️ If location = None, P1 score = 0 (no hard block)

---

## FOR KNOWLEDGE BASE UPDATES (Maintenance)

### When to Update This File:

1. **New Non-Geographic Pattern Discovered**
   - Users use new phrases in destination field
   - Add to non_geographic_patterns section
   - Update regex patterns
   - Test with real vessel data

2. **Priority Order Change**
   - Market feedback suggests different priority
   - Update priority_system hierarchy
   - Coordinate with proximity_scoring_matrix.txt
   - Document reasoning in changelog

3. **Geographic Database Expansion**
   - New ports/regions added to system
   - Update validation logic
   - Add fuzzy matching rules
   - Test matching accuracy

4. **Multiple Areas Logic Enhancement**
   - New selection criteria needed
   - Update selection_criteria method
   - Add tie-breaking rules
   - Document examples

5. **Edge Case Discovery**
   - New scenario not covered by current logic
   - Add to edge_cases section
   - Define handling procedure
   - Create example

### Update Principles:
- ✓ Maintain strict 4-level priority hierarchy
- ✓ Keep geographic validation comprehensive
- ✓ Coordinate with proximity_scoring_matrix.txt for integration
- ✓ Test with real vessel position data
- ✓ Document all edge cases with examples
- ✓ Version bump: minor change = +0.1, major change = +1.0
- ✓ Add detailed changelog entry

### Validation Checklist:
- [ ] Priority order clearly defined (1-4)
- [ ] All non-geographic patterns documented
- [ ] Geographic validation logic complete
- [ ] Multiple open areas handling tested
- [ ] Edge cases covered with solutions
- [ ] Integration with proximity_scoring_matrix.txt verified
- [ ] Fuzzy matching rules defined
- [ ] Database field mapping documented
- [ ] Examples for each priority level

### Testing Guidelines:
```
Test with real vessel position data:
1. Test Priority 1: open_port, open_area, multiple alternatives
2. Test Priority 2: valid destination, invalid destination
3. Test Priority 3: current_area fallback
4. Test Priority 4: no location available
5. Test non-geographic detection: "to order", "TBN", crew info
6. Test fuzzy matching: typos, variations
7. Test multiple open areas: selection logic
8. Verify integration with proximity scoring
```

---

## QUICK REFERENCE

**Priority Order (Strict):**
1. Open Information (open_port → open_area → alternative_open_areas)
2. Destination (if valid geographic)
3. Current Area (fallback)
4. Unknown (no location → P1 = 0)

**Valid Geographic:**
- Ports: "Istanbul", "Constanta", "Odessa"
- Regions: "Black Sea", "Marmara Sea", "East Med"
- Countries: "Turkey", "Romania", "Greece"
- Seas: "Black Sea", "Mediterranean"

**Invalid Non-Geographic:**
- Orders: "to order", "for orders", "awaiting orders"
- Nominations: "TBN", "TBA", "to be nominated"
- Crew: "Syrian crew", "Greek crew onboard"
- Instructions: "INCO", "awaiting instructions", "owners option"

**Multiple Open Areas:**
- Calculate proximity score for each to cargo loading port
- Select area with HIGHEST score
- Use selected area for all downstream scoring

**Example Scenarios:**
- open_port="Istanbul" → Use Istanbul (Priority 1)
- destination="to order" → Invalid, use current_area (Priority 3)
- alternative_areas=["Marmara","East Med"] + cargo="Odessa" → Select Marmara (closest)
- No data → Location Unknown, P1=0 (Priority 4)

**Critical Notes:**
- MUST run BEFORE proximity scoring
- Priority order is STRICT - never skip
- Geographic validation CRITICAL
- Output must be normalized entity
- If location=None, P1=0 (no hard block)

**Integration:**
```
vessel_location_determination.txt
    ↓ (outputs vessel_location)
proximity_scoring_matrix.txt
    ↓ (calculates P1 score)
MASTER_SCORING_SYSTEM.txt
```


# ═══════════════════════════════════════════════════════════════════
# VESSEL LOCATION DETERMINATION LOGIC
# VK Charts AI Scoring System
# ═══════════════════════════════════════════════════════════════════
#
# Логика определения местоположения судна для proximity scoring
# С fallback стратегией когда основная информация недоступна
#
# ═══════════════════════════════════════════════════════════════════

version: "1.1"
last_updated: "2024-12-01"
source: "Vitaly (VK Charts expert)"

# ═══════════════════════════════════════════════════════════════════
# VESSEL DATA STRUCTURE (from vessel_data & vessel_attributes)
# ═══════════════════════════════════════════════════════════════════

vessel_position_fields:
  description: "Fields parsed from email positions and stored in vessel_data"
  
  open_information:
    fields:
      - open_date
      - open_port
      - open_area
      - alternative_open_areas  # Array if multiple options
    priority: 1
    notes: "Primary source - vessel's declared open position"
    
  destination_information:
    fields:
      - destination
      - destination_date  # "as of" date
      - sight_of_date     # Alternative field name?
    priority: 2
    notes: "Secondary source - where vessel is heading"
    
  current_area:
    fields:
      - current_area
      - last_known_position
    priority: 3
    notes: "Fallback - where vessel currently is"

# ═══════════════════════════════════════════════════════════════════
# LOCATION DETERMINATION ALGORITHM
# ═══════════════════════════════════════════════════════════════════

location_determination_algorithm:
  
  step_1_check_open_information:
    priority: 1
    
    check_open_area:
      condition: "open_area IS NOT NULL AND open_area != ''"
      action: "Use open_area as vessel location"
      
      special_case_multiple_open_areas:
        condition: "alternative_open_areas array has multiple values"
        action: "Select open area closest to cargo loading port"
        method: "Calculate distance from each alternative to loading port, choose minimum"
        
        example:
          vessel: "MV EXAMPLE"
          open_areas:
            - "Marmara Sea"
            - "East Med"
            - "Adriatic"
          cargo_loading: "Odessa, Black Sea"
          
          distance_calculation:
            - area: "Marmara Sea"
              distance_to_odessa: "320 nm"
              proximity_score: 20
              
            - area: "East Med"
              distance_to_odessa: "450 nm"
              proximity_score: 8
              
            - area: "Adriatic"
              distance_to_odessa: "650 nm"
              proximity_score: 4
          
          selected_area: "Marmara Sea"
          reason: "Closest to loading port, highest proximity score"
    
    check_open_port:
      condition: "open_port IS NOT NULL AND open_port != ''"
      action: "Use open_port as vessel location"
      notes: "More specific than open_area"
      
    check_open_date:
      condition: "open_date in the future or recent past"
      validation: "Ensure open date is realistic (not too far in past/future)"
      
  step_2_check_destination:
    priority: 2
    condition: "IF open_information is NULL or empty"
    
    check_destination_value:
      condition: "destination IS NOT NULL AND destination != ''"
      
      validate_geographic:
        description: "Check if destination is valid geographic location"
        
        valid_destinations:
          - "Specific port name"
          - "Country name"
          - "Region name"
          - "Sea name"
          - "Anchorage name"
          
        invalid_destinations:
          - "to order"
          - "TO ORDER"
          - "for orders"
          - "Syrian crew"
          - "Greek crew onboard"
          - "TBN" (to be nominated)
          - "TBA" (to be advised)
          - "INCO" (intent confirmation)
          - "awaiting instructions"
          - "owners option"
          - Any crew information
          - Any non-geographic text
          
        validation_method:
          step_1: "Check against known ports/countries/regions database"
          step_2: "Use fuzzy matching for variations"
          step_3: "If no match in database → consider invalid"
          step_4: "Detect keywords indicating non-geographic (order, crew, TBN, etc)"
          
      action_if_valid:
        - "Use destination as vessel location"
        - "Apply to proximity scoring"
        
      action_if_invalid:
        - "Proceed to Step 3 (current_area)"
        - "Log invalid destination for future analysis"
  
  step_3_check_current_area:
    priority: 3
    condition: "IF both open_information and valid destination are unavailable"
    
    check_current_area:
      condition: "current_area IS NOT NULL AND current_area != ''"
      action: "Use current_area as vessel location"
      notes: "Last resort - where vessel currently is according to AIS or last update"
      
  step_4_fallback:
    priority: 4
    condition: "IF all above steps fail"
    action: "CANNOT DETERMINE LOCATION"
    scoring_impact: "Skip proximity scoring or assign default low score"
    user_notification: "Vessel location unknown - manual review required"

# ═══════════════════════════════════════════════════════════════════
# EXAMPLES OF LOCATION DETERMINATION
# ═══════════════════════════════════════════════════════════════════

examples:
  
  example_1_open_area_available:
    vessel_data:
      open_date: "2024-12-05"
      open_port: "Istanbul"
      open_area: "Marmara Sea"
      destination: "Black Sea"
      current_area: "Turkish Straits"
      
    result:
      selected_location: "Istanbul, Marmara Sea"
      reason: "Open information available (priority 1)"
      specific_port: true
      proximity_level: "level_7_marmara_sea"
      
  example_2_multiple_open_areas:
    vessel_data:
      open_date: "2024-12-10"
      open_area: null
      alternative_open_areas:
        - "East Med"
        - "Marmara Sea"
        - "West Med"
      destination: null
      current_area: "Mediterranean"
      
    cargo_loading:
      port: "Odessa"
      sea: "Black Sea"
      
    calculation:
      east_med_distance: "450 nm"
      marmara_distance: "320 nm"
      west_med_distance: "1200 nm"
      
    result:
      selected_location: "Marmara Sea"
      reason: "Closest alternative open area to loading port"
      proximity_level: "level_7_marmara_sea"
      score: 20
      
  example_3_destination_fallback:
    vessel_data:
      open_date: null
      open_port: null
      open_area: null
      destination: "Constanta"
      current_area: "Black Sea"
      
    validation:
      is_geographic: true
      matched_port: "Constanta, Romania"
      
    result:
      selected_location: "Constanta"
      reason: "Open info unavailable, using destination (priority 2)"
      proximity_level: "level_5_nearby_subregion"
      
  example_4_invalid_destination:
    vessel_data:
      open_date: null
      open_port: null
      open_area: null
      destination: "to order"
      current_area: "Mediterranean"
      
    validation:
      is_geographic: false
      reason: "Non-geographic keyword detected"
      
    result:
      selected_location: "Mediterranean"
      reason: "Invalid destination, using current_area (priority 3)"
      proximity_level: "depends on specific Med area"
      
  example_5_crew_information:
    vessel_data:
      open_date: null
      open_area: null
      destination: "Syrian crew onboard"
      current_area: "East Med"
      
    validation:
      is_geographic: false
      reason: "Crew information is not location"
      
    result:
      selected_location: "East Med"
      reason: "Invalid destination (crew info), using current_area"
      proximity_level: "level_9_east_med"
      
  example_6_no_location_data:
    vessel_data:
      open_date: null
      open_area: null
      destination: null
      current_area: null
      
    result:
      selected_location: "UNKNOWN"
      reason: "No location data available"
      action: "Skip proximity scoring or assign default low score (0)"
      user_notification: "Manual review required"

# ═══════════════════════════════════════════════════════════════════
# NON-GEOGRAPHIC DESTINATION PATTERNS
# ═══════════════════════════════════════════════════════════════════

non_geographic_patterns:
  description: "Patterns to detect invalid destinations"
  
  keywords_to_detect:
    orders:
      - "to order"
      - "for orders"
      - "awaiting orders"
      - "owners order"
      - "charterers order"
      
    nominations:
      - "TBN"
      - "to be nominated"
      - "TBA"
      - "to be advised"
      - "to be declared"
      
    crew_information:
      - "crew"
      - "Syrian crew"
      - "Greek crew"
      - "Ukrainian crew"
      - "onboard"
      
    awaiting_instructions:
      - "INCO"
      - "intent confirmation"
      - "awaiting instructions"
      - "awaiting details"
      
    options:
      - "owners option"
      - "charterers option"
      - "to be decided"
      
  regex_patterns:
    - "(?i)to\\s+order"
    - "(?i)for\\s+orders?"
    - "(?i)\\b(tbn|tba)\\b"
    - "(?i)crew\\b"
    - "(?i)onboard"
    - "(?i)awaiting"
    - "(?i)option"
    
  detection_method:
    step_1: "Convert destination to lowercase"
    step_2: "Check against keyword list"
    step_3: "Apply regex patterns"
    step_4: "If ANY match → invalid destination"

# ═══════════════════════════════════════════════════════════════════
# GEOGRAPHIC VALIDATION
# ═══════════════════════════════════════════════════════════════════

geographic_validation:
  description: "How to validate if destination is geographic location"
  
  data_sources:
    - "Airtable ports database"
    - "Countries list"
    - "Regions list"
    - "Seas list"
    - "Known anchorages"
    
  validation_steps:
    step_1_exact_match:
      - "Check destination against ports table"
      - "Check against countries table"
      - "Check against regions table"
      - "Check against seas table"
      
    step_2_fuzzy_match:
      - "Use fuzzy string matching (Levenshtein distance)"
      - "Account for typos and variations"
      - "Examples: 'Odesa' → 'Odessa', 'Konstanca' → 'Constanta'"
      
    step_3_common_abbreviations:
      known_abbreviations:
        - "POC → Pivdenny-Odessa-Chornomorsk"
        - "CVB → Constanta-Varna-Burgas"
        - "E Med → East Mediterranean"
        - "W Med → West Mediterranean"
        - "BS → Black Sea"
        - "MS → Marmara Sea"
        
    step_4_negative_keywords:
      - "If contains non-geographic keywords → invalid"
      - "Even if partially matches geographic location"
      - "Example: 'Odessa to order' → invalid (contains 'to order')"

# ═══════════════════════════════════════════════════════════════════
# MULTIPLE OPEN AREAS SELECTION
# ═══════════════════════════════════════════════════════════════════

multiple_open_areas_logic:
  description: "How to choose when vessel has multiple alternative open areas"
  
  selection_criteria:
    primary: "Proximity to cargo loading port"
    method: "Calculate distance or proximity score for each option"
    
  calculation_method:
    step_1: "For each alternative open area"
    step_2: "Calculate proximity score to cargo loading port"
    step_3: "Select area with HIGHEST proximity score"
    step_4: "Use selected area for all subsequent scoring"
    
  distance_calculation_options:
    
    option_a_use_proximity_matrix:
      description: "Apply proximity scoring matrix to each alternative"
      pros: "Reuses existing scoring logic"
      cons: "Need to know vessel size first"
      
    option_b_simple_distance:
      description: "Calculate nautical miles from each area to loading port"
      pros: "Size-agnostic, simpler"
      cons: "Less nuanced than scoring matrix"
      
    recommended: "option_a_use_proximity_matrix"
    
  tie_breaking:
    condition: "If two alternatives have same proximity score"
    rule_1: "Prefer more specific location over general region"
    rule_2: "Prefer area with better backhaul opportunities"
    rule_3: "If still tied, use first in list (arbitrary)"
    
  example_detailed:
    vessel:
      name: "MV EXAMPLE"
      dwt: 8500
      size_category: "coaster"
      
    alternatives:
      - "Istanbul (Marmara)"
      - "Piraeus (East Greece)"
      - "Limassol (Cyprus, East Med)"
      
    cargo:
      loading_port: "Odessa"
      loading_sea: "Black Sea"
      
    scoring_each:
      istanbul:
        proximity_level: "level_7_marmara_sea"
        base_score: 20
        distance: "320 nm"
        adjusted_score: 19.04
        
      piraeus:
        proximity_level: "level_8_izmir_nemrut_east_greece"
        base_score: 12
        distance: "520 nm"
        adjusted_score: 10.44
        
      limassol:
        proximity_level: "level_9_east_med"
        base_score: 8
        distance: "680 nm"
        adjusted_score: 5.96
        
    selected: "Istanbul (Marmara)"
    reason: "Highest adjusted proximity score (19.04)"

# ═══════════════════════════════════════════════════════════════════
# AI IMPLEMENTATION INSTRUCTIONS
# ═══════════════════════════════════════════════════════════════════

ai_implementation:
  
  function_pseudocode: |
    def determine_vessel_location(vessel_data, cargo_loading_port):
        # Step 1: Check open information
        if vessel_data.open_area:
            if is_array(vessel_data.open_area):
                return select_closest_open_area(vessel_data.open_area, cargo_loading_port)
            else:
                return vessel_data.open_area
                
        if vessel_data.open_port:
            return vessel_data.open_port
            
        # Step 2: Check destination
        if vessel_data.destination:
            if is_valid_geographic(vessel_data.destination):
                return vessel_data.destination
            else:
                log_invalid_destination(vessel_data.destination)
                # Proceed to step 3
                
        # Step 3: Check current area
        if vessel_data.current_area:
            return vessel_data.current_area
            
        # Step 4: No location available
        return None
        
    def is_valid_geographic(destination):
        # Check non-geographic keywords
        if contains_non_geographic_keywords(destination):
            return False
            
        # Check against geographic database
        if matches_port_or_region(destination):
            return True
            
        return False
        
    def select_closest_open_area(open_areas, loading_port):
        best_area = None
        best_score = -999
        
        for area in open_areas:
            score = calculate_proximity_score(area, loading_port)
            if score > best_score:
                best_score = score
                best_area = area
                
        return best_area
  
  integration_with_proximity_scoring:
    step_1: "Determine vessel location using above logic"
    step_2: "If location is None → skip proximity scoring"
    step_3: "If location is valid → proceed with proximity scoring matrix"
    step_4: "Use determined location as 'vessel_location' in proximity calculations"

# ═══════════════════════════════════════════════════════════════════
# EDGE CASES & SPECIAL HANDLING
# ═══════════════════════════════════════════════════════════════════

edge_cases:
  
  case_1_ambiguous_destination:
    example: "Med"
    problem: "Could be East Med, West Med, Central Med"
    solution: "Use current_area for more specificity, or ask user"
    
  case_2_very_old_open_date:
    example: "open_date: 2024-06-01" (current date: 2024-12-01)
    problem: "Open date 6 months old, likely outdated"
    solution: "Prefer current_area over open_area if open_date > 30 days old"
    
  case_3_contradictory_data:
    example:
      open_area: "Black Sea"
      destination: "Singapore"
      current_area: "Marmara Sea"
    problem: "Data doesn't make sense together"
    solution: "Trust priority order, but flag for manual review"
    
  case_4_multiple_ports_in_destination:
    example: "Constanta/Varna/Burgas"
    solution: "Parse as region 'CVB', use center point or all options"
    
  case_5_range_in_open_area:
    example: "open_area: East Med - West Med"
    solution: "Treat as two alternatives, select closest"

# ═══════════════════════════════════════════════════════════════════
# DATABASE FIELD MAPPING
# ═══════════════════════════════════════════════════════════════════

database_field_mapping:
  description: "Actual field names in vessel_data and vessel_attributes tables"
  
  note: "NEED TO VERIFY EXACT FIELD NAMES IN PRODUCTION DATABASE"
  
  likely_fields:
    vessel_data:
      - open_date
      - open_port_id (FK to ports table)
      - open_area (text or FK?)
      - destination (text)
      - current_area (text)
      
    vessel_attributes:
      - may contain parsed alternative_open_areas
      - may contain sight_of_date
      
  todo:
    - "Query actual database to confirm field names"
    - "Check if open_area is FK or text field"
    - "Verify alternative_open_areas storage method"
    - "Confirm destination field format"

# ═══════════════════════════════════════════════════════════════════
# METADATA & VERSIONING
# ═══════════════════════════════════════════════════════════════════

metadata:
  created_by: "Vitaly (VK Charts expert)"
  created_date: "2024-11-27"
  last_modified: "2024-12-01"
  version: "1.1.0"
  
  changelog:
    - version: "1.1.0"
      date: "2024-12-01"
      changes:
        - "Restructured SHORT SUMMARY in unified format"
        - "Added comprehensive HOW TO USE DOCUMENT with 3 sections:"
        - "  - For Developers (Laravel ↔ LangChain integration)"
        - "  - For AI/LangChain (7-step location determination algorithm)"
        - "  - For Knowledge Base Updates (maintenance procedures)"
        - "Added Quick Reference section"
        - "Enhanced documentation structure for clarity"
        - "Verified 4-level priority system (open → destination → current → unknown)"
        - "Confirmed geographic validation logic"
        - "Verified multiple open areas handling"
        - "Enhanced integration documentation with proximity_scoring_matrix.txt"
        - "No logic changes - purely documentation improvements"
      
    - version: "1.0.0"
      date: "2024-11-27"
      changes:
        - "Initial vessel location determination logic"
        - "Defined 4-level priority system"
        - "Established geographic validation rules"
        - "Created non-geographic pattern detection"
        - "Added multiple open areas selection logic"
        - "Documented edge cases and special handling"
        - "Created pseudocode for AI implementation"
  
  notes:
    - "This logic MUST run BEFORE proximity scoring"
    - "Priority order is STRICT - never skip steps"
    - "Geographic validation is CRITICAL - filters non-geographic text"
    - "Multiple open areas require proximity calculation for selection"
    - "Output must be normalized geographic entity"
    - "If location = None, P1 score = 0 (no hard block)"
